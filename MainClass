import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.Objects;

import javax.swing.*;

/* TODO
 * 
 */
 
public class MainClass 
{
	private final Color bgColor = new Color(0.031f, 0.00784f, 0.14118f, 1.f);
	private final Font titleFont = new Font("Verdana", Font.PLAIN, 50);
	private final Font smallFont = new Font("Verdana", Font.BOLD, 18);
	private static final String[][] standartModeButtons = {
			{"C", "DEL", "%", "รท"}, 
			{"7", "8", "9", "x"}, 
			{"4", "5", "6", "-"}, 
			{"1", "2", "3", "+"}, 
			{"mode", "0", ".", "="}};
	private static final String[][] expandedModeButtons = {
			{"2nd", "sin", "cos", "tan", "Pi"}, 
			{"|x|", "ln(x)", "log(a)b", "(", ")"},
			{"x^y", "AC", "DEL", "%", "รท"},
			{"sqrt(x)", "7", "8", "9", "x"}, 
			{"x!", "4", "5", "6", "-"}, 
			{"1/x", "1", "2", "3", "+"}, 
			{"mode", "e", "0", ".", "="}};

	private static JFrame f;
	private static JLabel operationField;
	private static JLabel outputField;
	public static JPanel buttonPanel;

	public static void main(String[] args) 
	{
		
		try
        {
        	// Adjusts the program's components to be of the same design language as the operating system that the program runs on
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
            JFrame.setDefaultLookAndFeelDecorated(true);
        }
        catch (Exception e)
        {
            JOptionPane.showMessageDialog(null, "UIManager failed to load the setLookAndFeel method!", "Error!", JOptionPane.ERROR_MESSAGE);
        }
		
		new MainClass();
	}
	
	MainClass()
	{
		initializeFrame();
	}
	
	void initializeFrame()
	{
		f = new JFrame("Calculator");
		f.setLayout(new BorderLayout());
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.getContentPane().setBackground(bgColor);
		
		// Dynamically scales the application depending on the screen resolution
		int height = (int)(Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 2);
		int width = (int)(height / 1.5);
		f.setPreferredSize(new Dimension(width, height));
		
		f.add(initializeComponents());
		f.addKeyListener(l);
		f.setFocusable(true);
		f.requestFocus();
        f.setFocusTraversalKeysEnabled(false);
		f.pack();
		f.setLocationRelativeTo(null);
		f.setResizable(false);
		f.setVisible(true);
	}
	
	Component initializeComponents()
	{
		JPanel mainPanel = new JPanel(new BorderLayout());
		JPanel topPanel = new JPanel(new BorderLayout());
		buttonPanel = new JPanel(new GridLayout(5, 4));
		GridBagConstraints g = new GridBagConstraints();
		
		outputField = new JLabel("0", SwingConstants.RIGHT);
		outputField.setFont(titleFont);
		outputField.setOpaque(true);
		outputField.setBackground(bgColor);
		outputField.setForeground(Color.WHITE);
		
		operationField = new JLabel(" ", SwingConstants.RIGHT);
		operationField.setFont(smallFont);
		operationField.setOpaque(true);
		operationField.setBackground(bgColor);
		operationField.setForeground(Color.WHITE);
		
		topPanel.add(outputField, BorderLayout.NORTH);
		topPanel.add(operationField, BorderLayout.CENTER);
		
		buttonPanel.setBackground(bgColor);
		
		g.fill = GridBagConstraints.BOTH;
		
		for(g.gridy = 0; g.gridy < standartModeButtons.length; g.gridy++)
			for(g.gridx = 0; g.gridx < standartModeButtons[0].length; g.gridx++)                                         
				buttonPanel.add(new ButtonClass(standartModeButtons[g.gridy][g.gridx]).getButton(), g);

		mainPanel.add(topPanel, BorderLayout.NORTH);
		mainPanel.add(buttonPanel, BorderLayout.CENTER);
		
		return mainPanel;
	}
	
	KeyListener l = new KeyListener()
	{

		@Override
		public void keyTyped(KeyEvent e) 
		{
			// Invoked when a key is typed. Uses KeyChar, char output
			
		}

		@Override
		public void keyPressed(KeyEvent e) // Invoked when a physical key is pressed down. Uses KeyCode, int output
		{
			if(e.getKeyCode() == KeyEvent.VK_BACK_SPACE)
				deleteCharacter();
			else if(validInput(e.getKeyCode()))
				addCharacter(Character.toString(e.getKeyChar()));
		}

		@Override
		public void keyReleased(KeyEvent e) {
			// called whenever a button is released
		}
	};
	
	static void deleteCharacter()
	{
		// deletes the last character entered by the user
		String adjustedText = outputField.getText().length() > 1 ? outputField.getText().substring(0, outputField.getText().length()-1) : "0";
		outputField.setText(adjustedText);
		updateOperationField(outputField.getText());
	}
	
	static void addCharacter(String text)
	{
		// Identifies the user's character as either being a number or an operator
		try
		{
			Integer.parseInt(text);
			
			// either replaces the initial 0 with a number or appends the number to the string
			String adjustedText = Objects.equals(outputField.getText(), "0") ? 
					text : outputField.getText() + text;
			
			outputField.setText(adjustedText);
			updateOperationField(outputField.getText());
		}
		catch(Exception exception)
		{
			// TODO: special case for the equals sign
			outputField.setText(outputField.getText() + text);
		}
	}
	
	private static ArrayList<Integer> opNum;
	private static ArrayList<Character> opName;
	
	static void updateOperationField(String text)
	{
		if(Objects.equals(text, "0"))
		{
			operationField.setText(" ");
		}
		else // Evaluate the answer
		{
			// Scans through the string and finds any operators
			// Fills the arraylists with them in order of appearance
			findOperators(text);
			
			// if any operators are present, calculate the result
			while(opNum.size() != 0)
			{
				// pick the highest priority operator, scan through the list to find the numbers surrounding it
				// Priority: division, multiplication, addition, subtraction
				text = compute(text, '/');
				text = compute(text, '*');
				text = compute(text, '-');
				text = compute(text, '+');
			}
			operationField.setText("= " + text);
		}
	}
	
	static void findOperators(String text)
	{
		// Stores the locations of all the operators in the text and their symbols
		opNum = new ArrayList<Integer>();
		opName = new ArrayList<Character>();
		
		for(int i = 1; i < text.length(); i++)
		{
			if(Character.getNumericValue(text.charAt(i)) == -1 && text.charAt(i) != '.')
			{
				opNum.add(i);
				opName.add(text.charAt(i));
			}
		}
	}
	
	// An enhanced switch statement is used, it is a preview feature in Java 13
	@SuppressWarnings("preview")
	static String compute(String text, char operator)
	{
		String result;
		int start, end;
		StringBuilder temp;
		
		while(true)
		{
			int arrIndex = opName.indexOf(operator);
			
			// checks that the operator is inside the string and is not the last character
			if(arrIndex != -1 && opNum.get(arrIndex) < text.length()-1)
			{
				// if the operator is the first one, start from the beginning of the string`
				if(arrIndex == 0)
					start = 0;
				else // start from the previously available operator
					start = opNum.get(arrIndex - 1) + 1;
				
				// if the operator is the last one, end with the end of the string
				if(arrIndex + 1 == opNum.size())
					end = text.length();
				else // end with the next available operator
					end = opNum.get(arrIndex + 1);

				double x = Double.parseDouble(text.substring(start, opNum.get(arrIndex)));
				double y = Double.parseDouble(text.substring(opNum.get(arrIndex) + 1, end));
				
				temp = new StringBuilder(text);
				result = switch (operator)
				{
					case '+':
						yield String.valueOf(x+y);
					
					case '-':
						yield String.valueOf(x-y);
						
					case '*':
						yield String.valueOf(x*y);
						
					case '/':
						yield String.valueOf(x/y);
					
					default:
						yield "Error";
				};

				temp.replace(start, end, result);
				text = temp.toString();
			}
			else if(arrIndex == -1)
				break;
			else
			{
				opNum.remove(arrIndex);
				opName.remove(arrIndex);
				text = text.substring(0, text.length()-1);
				break;
			}
			
			// Revalidates the modified string
			findOperators(text);
		}
		return text;
	}
	
	static void updateForButtons(String text)
	{
		if(text.equals("DEL"))
			deleteCharacter();
		else
		{
			addCharacter(text);
		}
			
		
		f.requestFocus();
	}
	
	private final int[] codes = {45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 61, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 109, 110, 111, 151, 521};
	// Checks if the user's input is within a valid range of characters
	boolean validInput(int code)
	{
		for(int i : codes)
			if(code == i)
				return true;
		
			return false;
	}
}
