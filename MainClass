import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Objects;

import javax.swing.*;

/* TODO
 * 
 */
 
public class MainClass 
{
	private final Color bgColor = new Color(0.031f, 0.00784f, 0.14118f, 1.f);
	private final static Font titleFont = new Font("Verdana", Font.BOLD, 60);
	private final static Font smallFont = new Font("Verdana", Font.BOLD, 24);
	private static final String[][] standartModeButtons = {
			{"C", "DEL", "%", "÷"}, 
			{"7", "8", "9", "x"}, 
			{"4", "5", "6", "-"}, 
			{"1", "2", "3", "+"}, 
			{"mode", "0", ".", "="}};
	private static final String[][] expandedModeButtons = {
			{"2nd", "sin", "cos", "tan", "π"}, 
			{"deg", "ln(x)", "lg(x)", "(", ")"},
			{"EXP", "C", "DEL", "√", "÷"},
			{"x^y", "7", "8", "9", "x"}, 
			{"|x|", "4", "5", "6", "-"}, 
			{"x!", "1", "2", "3", "+"}, 
			{"mode", "e", "0", ".", "="}};
	private static final String[] operatorsPriority = {"sin", "cos", "tan", "arcsin", "arccos", "arctan", "lg", "ln",
														"√", "^", "EXP", "!", "/", "*", "+", "-"};
	private static ArrayList<Integer> operatorsIndexes;
	private static ArrayList<String> operatorsNames;
	
	private static JFrame f;
	private static JLabel operationField;
	private static JLabel outputField;
	public static JPanel buttonPanel;
	private static boolean scientificMode = false;
	private static boolean degrees = true;

	public static void main(String[] args) 
	{
		/*
		try
        {
        	// Adjusts the program's components to be of the same design language as the operating system that the program runs on
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
            JFrame.setDefaultLookAndFeelDecorated(true);
        }
        catch (Exception e)
        {
            JOptionPane.showMessageDialog(null, "UIManager failed to load the setLookAndFeel method!", "Error!", JOptionPane.ERROR_MESSAGE);
        }
		*/
		
		new MainClass();
	}
	
	MainClass()
	{
		EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
            	initializeFrame();
            }
		});
	}
	
	void initializeFrame()
	{
		f = new JFrame("Calculator");
		f.setLayout(new BorderLayout());
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.getContentPane().setBackground(bgColor);
		
		// Dynamically scales the application depending on the screen resolution
		int height = (int)(Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 1.7);
		int width = (int)(height / 1.3);
		
		f.setPreferredSize(new Dimension(width, height));
		f.add(initializeComponents());
		f.addKeyListener(l);
		f.setFocusable(true);
		f.requestFocus();
        f.setFocusTraversalKeysEnabled(false);
		f.pack();
		f.setLocationRelativeTo(null);
		f.setResizable(false);
		f.setVisible(true);
	}
	
	Component initializeComponents()
	{
		JPanel mainPanel = new JPanel(new BorderLayout());
		JPanel topPanel = new JPanel(new BorderLayout());
		buttonPanel = new JPanel();
		
		outputField = new JLabel("0", SwingConstants.RIGHT);
		outputField.setFont(titleFont);
		outputField.setOpaque(true);
		outputField.setBackground(bgColor);
		outputField.setForeground(Color.WHITE);
		
		operationField = new JLabel(" ", SwingConstants.RIGHT);
		operationField.setFont(smallFont);
		operationField.setOpaque(true);
		operationField.setBackground(bgColor);
		operationField.setForeground(Color.WHITE);
		
		topPanel.add(outputField, BorderLayout.NORTH);
		topPanel.add(operationField, BorderLayout.CENTER);
		
		buttonPanel.setBackground(bgColor);
		
		setMode();

		mainPanel.add(topPanel, BorderLayout.NORTH);
		mainPanel.add(buttonPanel, BorderLayout.CENTER);
		
		return mainPanel;
	}
	
	KeyListener l = new KeyListener()
	{

		@Override
		public void keyTyped(KeyEvent e) 
		{
			// Invoked when a key is typed. Uses KeyChar, char output
			
		}

		@Override
		public void keyPressed(KeyEvent e) // Invoked when a physical key is pressed down. Uses KeyCode, int output
		{
			//updateOperationField("-1.0*(2");
			if(e.getKeyCode() == KeyEvent.VK_BACK_SPACE)
				deleteCharacter();
			else if(validInput(e.getKeyCode()))
				addCharacter(Character.toString(e.getKeyChar()));
		}

		@Override
		public void keyReleased(KeyEvent e) {
			// called whenever a button is released
		}
	};
	
	static void deleteCharacter()
	{
		// deletes the last character entered by the user
		String adjustedText = outputField.getText().length() > 1 ? outputField.getText().substring(0, outputField.getText().length()-1) : "0";
		outputField.setText(adjustedText);
		updateOperationField(outputField.getText());
	}
	
	static void addCharacter(String text)
	{
		// Identifies the user's character as either being a number or an operator
		try
		{
			Integer.parseInt(text);
			
			// either replaces the initial 0 with a number or appends the number to the string
			String adjustedText = outputField.getText().equals("0") ? text : outputField.getText() + text;
			
			outputField.setText(adjustedText);
		}
		catch(Exception exception) // an operator had been entered
		{
			// TODO: special case for the equals sign
			// If the input line is empty and a special function is entered
			if(outputField.getText().equals("0"))
			{
				switch(text)
				{
					case "+": 
					case "-":
					case "*":
					case "/":
					case ".":
					case "!":
					case "^":
						outputField.setText("0" + text);
					break;
					
					default:
						outputField.setText(text);
				}
			}
			else // when there are already numbers/operators entered in the input line of the calculator
			{
				switch(text)
				{
					case "+": 
					case "-":
					case "*":
					case "/":
					case ".":
					case "!":
					case "^":
						try // checks to see if the last character entered was an operator or a number
						{
							Integer.parseInt(Character.toString(outputField.getText().charAt(outputField.getText().length()-1)));
							
							outputField.setText(outputField.getText() + text);
						}
						catch(Exception e)
						{ 	// if the last character in the calculator string was an operator (with an exception of the closed bracket), a new operator replaces the previous one
							if(outputField.getText().charAt(outputField.getText().length()-1) == ')')
								outputField.setText(outputField.getText() + text);
							else
								outputField.setText(outputField.getText().substring(0, outputField.getText().length()-1) + text);
						}
					break;
					
					case ")":
						try // checks to see if the last character entered was an operator or a number
						{
							Integer.parseInt(Character.toString(outputField.getText().charAt(outputField.getText().length()-1)));
							
							outputField.setText(outputField.getText() + ")");
						}
						catch(Exception e)
						{
							if(outputField.getText().charAt(outputField.getText().length()-1) != ')')
								outputField.setText(outputField.getText() + "0)");
						}
					break;
					
					case "(":
						try
						{
							Integer.parseInt(Character.toString(outputField.getText().charAt(outputField.getText().length()-1)));
							outputField.setText(outputField.getText() + "*(");
						}
						catch (Exception e)
						{
							if(outputField.getText().charAt(outputField.getText().length()-1) != ')')
								outputField.setText(outputField.getText() + "(");
							else
								outputField.setText(outputField.getText() + "*(");
						}
					break;
					
					default:
						outputField.setText(outputField.getText() + "*" + text);
				}
			}
		}
		updateOperationField(outputField.getText());
	}
	
	 static void setAnswerMode(boolean answerMode)
	{
		if(answerMode)
		{
			operationField.setFont(titleFont);
			outputField.setFont(smallFont);
		}
		else
		{
			operationField.setFont(smallFont);
			outputField.setFont(titleFont);
		}
	}
	
	static void updateOperationField(String text)
	{
		if(Objects.equals(text, "0"))
		{
			operationField.setText(" ");
		}
		else // Evaluate the answer
		{
			// if there are any operators, calculate the result
			while(hasOperators(text))
				text = brackets(text);
			
			operationField.setText("= " + text);
		}
	}
	
	static boolean hasOperators(String text)
	{
		int i;
		// the minus in front of the first number like '-1' should not be considered as an operator
		if(text.charAt(0) == '-')
			i = 1;
		else
			i = 0;
		
		// goes through the string to find any operators beside the dot
		for(; i < text.length(); i++)
		{
			try 
			{
				Integer.parseInt(Character.toString(text.charAt(i)));
			}
			catch (Exception e)
			{
				if(text.charAt(i) != '.')
					return true;
			}
		}
		return false;
	}
	
	static void findOperators(String text)
	{
		// Stores the locations of all the operators in the text and their symbols
		operatorsIndexes = new ArrayList<Integer>();
		operatorsNames = new ArrayList<String>();
		
		int i;
		// the minus in front of the first number like '-1' should not be considered as an operator
		if(text.charAt(0) == '-')
			i = 1;
		else
			i = 0;
		
		for(; i < text.length(); i++)
		{
			try 
			{
				Integer.parseInt(Character.toString(text.charAt(i)));
			}
			catch (Exception e)
			{
				if(text.charAt(i) != '.')
				{
					operatorsIndexes.add(i);
					operatorsNames.add(Character.toString(text.charAt(i)));
				}
			}
		}
	}
	
	// should be a recursive function
	static String brackets(String initialText)
	{
		String textInBrackets;
		
		findOperators(initialText);
		
		// tries to find the brackets in the input string
		boolean openBracket = operatorsNames.indexOf("(") == -1 ? false : true;
		boolean closedBracket = operatorsNames.indexOf(")") == -1 ? false : true;
		
		//if there are no brackets, calculate the whole string
		if(!openBracket && !closedBracket)
		{
			// picks the highest priority operator, scans through the list to find the numbers surrounding it
			for(String i : operatorsPriority)
			{
				if(operatorsIndexes.size() > 0)
					initialText = compute(initialText, i);
				else
					break;
			}
			return initialText;
		}
		else if(openBracket && !closedBracket) // if only the closed bracket exists, the open bracket is implied to be at the beginning of the string
		{
			initialText = initialText +  ")";
			findOperators(initialText);
		}
		else if(!openBracket && closedBracket) // if only the open bracket exists, the closed bracket is implied to be at the end of the string
		{
			initialText = "(" + initialText;
			findOperators(initialText);
		}
		
		int openBracketIndex = operatorsIndexes.get(operatorsNames.indexOf("("));
		int closedBracketIndex = operatorsIndexes.get(operatorsNames.indexOf(")"));
		
		// if the brackets are right next to each other, return nothing as text
		if(openBracketIndex + 1 == closedBracketIndex)
			textInBrackets = "0";
		else
			textInBrackets = initialText.substring(openBracketIndex + 1, closedBracketIndex);
		 
		/*
		operatorsIndexes.remove(operatorsNames.indexOf("("));
		operatorsNames.remove(operatorsNames.indexOf("("));
		operatorsIndexes.remove(operatorsNames.indexOf(")"));
		operatorsNames.remove(operatorsNames.indexOf(")"));
		*/
		// the 'brackets' function calls on itself to check for more brackets
		// adjust (wrong)
		StringBuffer buf = new StringBuffer(initialText);
		buf.replace(openBracketIndex, closedBracketIndex + 1, brackets(textInBrackets));
		return buf.toString();
	}
	
	// An enhanced switch statement is used, it is a preview feature in Java 13
	@SuppressWarnings("preview")
	static String compute(String text, String operator)
	{
		String result;
		int start, end;
		StringBuilder temp;
		
		while(true)
		{
			int arrIndex = operatorsNames.indexOf(operator);
			
			// checks that the operator is inside the string and is not the last character
			if(arrIndex != -1 && operatorsIndexes.get(arrIndex) < text.length()-1)
			{
				// if the operator is the first one, start from the beginning of the string`
				if(arrIndex == 0)
					start = 0;
				else // start from the previously available operator
					start = operatorsIndexes.get(arrIndex - 1) + 1;
				
				// if the operator is the last one, end with the end of the string
				if(arrIndex + 1 == operatorsIndexes.size())
					end = text.length();
				else // end with the next available operator
					end = operatorsIndexes.get(arrIndex + 1);

				double x = Double.parseDouble(text.substring(start, operatorsIndexes.get(arrIndex)));
				double y = Double.parseDouble(text.substring(operatorsIndexes.get(arrIndex) + 1, end));
				
				temp = new StringBuilder(text);
				result = switch (operator)
				{
					case "+":
						yield String.valueOf(x+y);
					
					case "-":
						yield String.valueOf(x-y);
						
					case "*":
						yield String.valueOf(x*y);
						
					case "/":
						yield String.valueOf(x/y);
					
					default:
						yield "Error";
				};

				temp.replace(start, end, result);
				text = temp.toString();
			}
			else if(arrIndex == -1) // if the operator is not in the string, exit the "compute"
				break;
			else
			{
				operatorsIndexes.remove(arrIndex);
				operatorsNames.remove(arrIndex);
				text = text.substring(0, text.length()-1);
				break;
			}
			
			// Revalidates the modified string
			findOperators(text);
		}
		return text;
	}
	
	static void updateForButtons(String text)
	{
		/*
		 * {"2nd", "sin", "cos", "tan", "π"}, 
			{"deg", "ln(x)", "lg(x)", "(", ")"},
			{"EXP", "C", "DEL", "√", "÷"},
			{"x^y", "7", "8", "9", "x"}, 
			{"|x|", "4", "5", "6", "-"}, 
			{"x!", "1", "2", "3", "+"}, 
			{"mode", "e", "0", ".", "="}};
		 */
		setAnswerMode(false);
		
		switch(text)
		{
			case "=":
			// if the equal sign is pressed, enter the 'answer' mode
				setAnswerMode(true);
			break;
			
			case "DEL":
				deleteCharacter();
			break;
			
			case "C":
				outputField.setText("0");
				updateOperationField(outputField.getText());
			break;
				
			case "mode": // switches the calculator modes
				scientificMode = !scientificMode;
				setMode();
			break;
				
			case "x":
				addCharacter("*");
			break;
			
			case "÷":
				addCharacter("/");
			break;	
			
			case "sin":
			case "cos":
			case "tan":
			case "EXP":
				addCharacter(text + "(");
			break;
			
			case "ln(x)":
			case "lg(x)":
				addCharacter(text.substring(0, text.length() - 2));
			break;
			
			case "x^y":
				addCharacter("^");
			break;
			
			case "x!":
				addCharacter("!");
			break;
			
			case "deg": // changes from radians to degrees
			case "rad":
				degrees = !degrees;
			break;
			
			default:
				addCharacter(text);
				break;
		}
			
		f.requestFocus();
	}
	
	// Function responsible for button render depending on the calculator mode currently set (normal vs scientific)
	static void setMode()
	{
		GridBagConstraints g = new GridBagConstraints();
		g.fill = GridBagConstraints.BOTH;
		
		String[][] copiedArray;
		buttonPanel.removeAll();
		
		// if the calculator is currently in standard mode
		if(!scientificMode)
		{
			buttonPanel.setLayout(new GridLayout(5, 4));
			copiedArray = Arrays.copyOf(standartModeButtons, standartModeButtons.length);
		}
		else // if the calculator is currently in scientific mode
		{
			buttonPanel.setLayout(new GridLayout(7, 5));
			copiedArray = Arrays.copyOf(expandedModeButtons, expandedModeButtons.length);
		}
		
		for(g.gridy = 0; g.gridy < copiedArray.length; g.gridy++)
			for(g.gridx = 0; g.gridx < copiedArray[0].length; g.gridx++)                                         
				buttonPanel.add(new ButtonClass(copiedArray[g.gridy][g.gridx]).getButton(), g);
		
		f.revalidate();
		f.repaint();
	}
	
	private final int[] codes = {45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 61, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 109, 110, 111, 151, 521};
	// Checks if the user's input is within a valid range of characters
	boolean validInput(int code)
	{
		for(int i : codes)
			if(code == i)
				return true;
		
			return false;
	}
}
