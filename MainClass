import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Objects;

import javax.swing.*;

/* TODO
 * 
 */
 
public class MainClass 
{
	private final Color bgColor = new Color(0.031f, 0.00784f, 0.14118f, 1.f);
	private final Font titleFont = new Font("Verdana", Font.BOLD, 60);
	private final Font smallFont = new Font("Verdana", Font.BOLD, 18);
	private static final String[][] standartModeButtons = {
			{"C", "DEL", "%", "÷"}, 
			{"7", "8", "9", "x"}, 
			{"4", "5", "6", "-"}, 
			{"1", "2", "3", "+"}, 
			{"mode", "0", ".", "="}};
	private static final String[][] expandedModeButtons = {
			{"2nd", "sin", "cos", "tan", "π"}, 
			{"deg", "ln(x)", "log(a)x", "(", ")"},
			{"|x|", "C", "DEL", "%", "÷"},
			{"x^y", "7", "8", "9", "x"}, 
			{"√x", "4", "5", "6", "-"}, 
			{"x!", "1", "2", "3", "+"}, 
			{"mode", "e", "0", ".", "="}};

	private static JFrame f;
	private static JLabel operationField;
	private static JLabel outputField;
	public static JPanel buttonPanel;
	private static boolean scientificMode = false;
	private static boolean degrees = true;

	public static void main(String[] args) 
	{
		/*
		try
        {
        	// Adjusts the program's components to be of the same design language as the operating system that the program runs on
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
            JFrame.setDefaultLookAndFeelDecorated(true);
        }
        catch (Exception e)
        {
            JOptionPane.showMessageDialog(null, "UIManager failed to load the setLookAndFeel method!", "Error!", JOptionPane.ERROR_MESSAGE);
        }
		*/
		
		new MainClass();
	}
	
	MainClass()
	{
		EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
            	initializeFrame();
            }
		});
	}
	
	void initializeFrame()
	{
		f = new JFrame("Calculator");
		f.setLayout(new BorderLayout());
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.getContentPane().setBackground(bgColor);
		
		// Dynamically scales the application depending on the screen resolution
		int height = (int)(Toolkit.getDefaultToolkit().getScreenSize().getHeight() / 1.7);
		int width = (int)(height / 1.3);
		
		f.setPreferredSize(new Dimension(width, height));
		f.add(initializeComponents());
		f.addKeyListener(l);
		f.setFocusable(true);
		f.requestFocus();
        f.setFocusTraversalKeysEnabled(false);
		f.pack();
		f.setLocationRelativeTo(null);
		f.setResizable(false);
		f.setVisible(true);
	}
	
	Component initializeComponents()
	{
		JPanel mainPanel = new JPanel(new BorderLayout());
		JPanel topPanel = new JPanel(new BorderLayout());
		buttonPanel = new JPanel();
		
		outputField = new JLabel("0", SwingConstants.RIGHT);
		outputField.setFont(titleFont);
		outputField.setOpaque(true);
		outputField.setBackground(bgColor);
		outputField.setForeground(Color.WHITE);
		
		operationField = new JLabel(" ", SwingConstants.RIGHT);
		operationField.setFont(smallFont);
		operationField.setOpaque(true);
		operationField.setBackground(bgColor);
		operationField.setForeground(Color.WHITE);
		
		topPanel.add(outputField, BorderLayout.NORTH);
		topPanel.add(operationField, BorderLayout.CENTER);
		
		buttonPanel.setBackground(bgColor);
		
		setMode();

		mainPanel.add(topPanel, BorderLayout.NORTH);
		mainPanel.add(buttonPanel, BorderLayout.CENTER);
		
		return mainPanel;
	}
	
	KeyListener l = new KeyListener()
	{

		@Override
		public void keyTyped(KeyEvent e) 
		{
			// Invoked when a key is typed. Uses KeyChar, char output
			
		}

		@Override
		public void keyPressed(KeyEvent e) // Invoked when a physical key is pressed down. Uses KeyCode, int output
		{
			if(e.getKeyCode() == KeyEvent.VK_BACK_SPACE)
				deleteCharacter();
			else if(validInput(e.getKeyCode()))
				addCharacter(Character.toString(e.getKeyChar()));
		}

		@Override
		public void keyReleased(KeyEvent e) {
			// called whenever a button is released
		}
	};
	
	static void deleteCharacter()
	{
		// deletes the last character entered by the user
		String adjustedText = outputField.getText().length() > 1 ? outputField.getText().substring(0, outputField.getText().length()-1) : "0";
		outputField.setText(adjustedText);
		updateOperationField(outputField.getText());
	}
	
	static void addCharacter(String text)
	{
		// Identifies the user's character as either being a number or an operator
		try
		{
			Integer.parseInt(text);
			
			// either replaces the initial 0 with a number or appends the number to the string
			String adjustedText = outputField.getText().equals("0") ? text : outputField.getText() + text;
			
			outputField.setText(adjustedText);
			updateOperationField(outputField.getText());
		}
		catch(Exception exception) // an operator had been entered
		{
			// TODO: special case for the equals sign
			// If the input line is empty and a special function is entered
			if(outputField.getText().equals("0"))
			{
				switch(text)
				{
					case "+": 
					case "-":
					case "*":
					case "/":
					case ".":
					case "!":
					case "^":
						outputField.setText(outputField.getText() + text);
					break;
					
					case "π":
						outputField.setText("π");
					break;
					
					default:
						outputField.setText(text + outputField.getText());
				}
			}
			else // when there are already numbers/operators entered in the input line of the calculator
			{
				switch(text)
				{
					case "+": 
					case "-":
					case "*":
					case "/":
					case ".":
					case "!":
					case "^":
						try // checks to see if the last character entered was an operator or a number
						{
							Integer.parseInt(Character.toString(outputField.getText().charAt(outputField.getText().length()-1)));
							
							outputField.setText(outputField.getText() + text);
						}
						catch(Exception e)
						{ 	// if the last character in the calculator string was an operator, a new operator replaces the previous one
							outputField.setText(outputField.getText().substring(0, outputField.getText().length()-1) + text);
						}
						
						
					break;
					
					case "π":
						outputField.setText("π");
					break;
					
					default:
						outputField.setText(text + outputField.getText());
				}
			}
				
		}
	}
	
	private static ArrayList<Integer> opNum;
	private static ArrayList<Character> opName;
	
	static void updateOperationField(String text)
	{
		if(Objects.equals(text, "0"))
		{
			operationField.setText(" ");
		}
		else // Evaluate the answer
		{
			// Scans through the string and finds any operators
			// Fills the arraylists with them in order of appearance
			findOperators(text);
			
			// if any operators are present, calculate the result
			while(opNum.size() != 0)
			{
				// pick the highest priority operator, scan through the list to find the numbers surrounding it
				// Priority: power, brackets, division, multiplication, addition, subtraction
				text = brackets(text);
				text = compute(text, '/');
				text = compute(text, '*');
				text = compute(text, '-');
				text = compute(text, '+');
			}
			operationField.setText("= " + text);
		}
	}
	
	static void findOperators(String text)
	{
		// Stores the locations of all the operators in the text and their symbols
		opNum = new ArrayList<Integer>();
		opName = new ArrayList<Character>();
		
		for(int i = 1; i < text.length(); i++)
		{
			if(Character.getNumericValue(text.charAt(i)) == -1 && text.charAt(i) != '.')
			{
				opNum.add(i);
				opName.add(text.charAt(i));
			}
		}
	}
	
	static String brackets(String initialText)
	{
		// all the compute functions will go into here
		
		String textInBrackets;
		while(true)
		{
			int openBracketIndex = opName.indexOf('(');
			int closedBracketIndex = opName.indexOf(')');
			
			// checks that the open bracket is inside the string and is not the last character
			if(openBracketIndex == -1 || opNum.get(openBracketIndex) == initialText.length()-1)
				openBracketIndex = 0;
				
			if(closedBracketIndex == -1 || opNum.get(closedBracketIndex) == initialText.length()-1)
				closedBracketIndex = 0;
			
			if(openBracketIndex != 0 && closedBracketIndex != 0)
			{
				textInBrackets = initialText.substring(openBracketIndex, closedBracketIndex);
				return textInBrackets;
			}
			else
				return initialText;
		}
	}
	
	// An enhanced switch statement is used, it is a preview feature in Java 13
	@SuppressWarnings("preview")
	static String compute(String text, char operator)
	{
		String result;
		int start, end;
		StringBuilder temp;
		
		while(true)
		{
			int arrIndex = opName.indexOf(operator);
			
			// checks that the operator is inside the string and is not the last character
			if(arrIndex != -1 && opNum.get(arrIndex) < text.length()-1)
			{
				// if the operator is the first one, start from the beginning of the string`
				if(arrIndex == 0)
					start = 0;
				else // start from the previously available operator
					start = opNum.get(arrIndex - 1) + 1;
				
				// if the operator is the last one, end with the end of the string
				if(arrIndex + 1 == opNum.size())
					end = text.length();
				else // end with the next available operator
					end = opNum.get(arrIndex + 1);

				double x = Double.parseDouble(text.substring(start, opNum.get(arrIndex)));
				double y = Double.parseDouble(text.substring(opNum.get(arrIndex) + 1, end));
				
				temp = new StringBuilder(text);
				result = switch (operator)
				{
					case '+':
						yield String.valueOf(x+y);
					
					case '-':
						yield String.valueOf(x-y);
						
					case '*':
						yield String.valueOf(x*y);
						
					case '/':
						yield String.valueOf(x/y);
					
					default:
						yield "Error";
				};

				temp.replace(start, end, result);
				text = temp.toString();
			}
			else if(arrIndex == -1)
				break;
			else
			{
				opNum.remove(arrIndex);
				opName.remove(arrIndex);
				text = text.substring(0, text.length()-1);
				break;
			}
			
			// Revalidates the modified string
			findOperators(text);
		}
		return text;
	}
	
	static void updateForButtons(String text)
	{
		/*
		 * {"2nd", "sin", "cos", "tan", "Pi"}, 
			{"|x|", "ln(x)", "log(a)b", "(", ")"},
			{"x^y", "C", "DEL", "%", "÷"},
			{"sqrt(x)", "7", "8", "9", "x"}, 
			{"x!", "4", "5", "6", "-"}, 
			{"1/x", "1", "2", "3", "+"}, 
			{"mode", "e", "0", ".", "="}};
		 */
		switch(text)
		{
			case "DEL":
				deleteCharacter();
			break;
			
			case "C":
				outputField.setText("0");
				updateOperationField(outputField.getText());
			break;
				
			case "mode": // switches the calculator modes
				scientificMode = !scientificMode;
				setMode();
			break;
				
			case "x":
				addCharacter("*");
			break;
			
			case "÷":
				addCharacter("/");
			break;	
			
			case "sin":
				addCharacter("sin(");
			break;
			
			case "cos":
				addCharacter("cos(");
			break;
			
			case "tan":
				addCharacter("tan(");
			break;
			
			case "deg": // changes from radians to degrees
			case "rad":
				degrees = !degrees;
				break;
			
			default:
				addCharacter(text);
				break;
		}
			
		f.requestFocus();
	}
	
	// Function responsible for button render depending on the calculator mode currently set (normal vs scientific)
	static void setMode()
	{
		GridBagConstraints g = new GridBagConstraints();
		g.fill = GridBagConstraints.BOTH;
		
		String[][] copiedArray;
		buttonPanel.removeAll();
		
		// if the calculator is currently in standard mode
		if(!scientificMode)
		{
			buttonPanel.setLayout(new GridLayout(5, 4));
			copiedArray = Arrays.copyOf(standartModeButtons, standartModeButtons.length);
		}
		else // if the calculator is currently in scientific mode
		{
			buttonPanel.setLayout(new GridLayout(7, 5));
			copiedArray = Arrays.copyOf(expandedModeButtons, expandedModeButtons.length);
		}
		
		for(g.gridy = 0; g.gridy < copiedArray.length; g.gridy++)
			for(g.gridx = 0; g.gridx < copiedArray[0].length; g.gridx++)                                         
				buttonPanel.add(new ButtonClass(copiedArray[g.gridy][g.gridx]).getButton(), g);
		
		f.revalidate();
		f.repaint();
	}
	
	private final int[] codes = {45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 61, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 109, 110, 111, 151, 521};
	// Checks if the user's input is within a valid range of characters
	boolean validInput(int code)
	{
		for(int i : codes)
			if(code == i)
				return true;
		
			return false;
	}
}
